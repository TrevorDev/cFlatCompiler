//THIS FILE IS GENERATED IN proNode/nodes.jc
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "nodes.h"

extern HashTable *global_type_table;
HashTable *local_struct_iden_table;
extern HashTable *global_iden_table;
extern HashTable *local_iden_table;
char * cur_assign_var_decl_type = NULL;

int nodeId = 0;
FILE* fp;
int structCounter = 0;

int insert_symbol_table_entry(void *key, void *data){
	if (!hash_table_retrieve(local_iden_table, key)){
		hash_table_insert(local_iden_table, key, data);
		return 1;
	}

	if (!hash_table_retrieve(global_iden_table, key)){
		hash_table_insert(global_iden_table, key, data);
		return 1;
	}

	return 0;
}

unsigned int hash (void *v)
{
	char *s0 = v;
	unsigned int h=0;
	char *s;
	for (s = s0; *s; s++) {
		h = h*65599 + *s;
	}
	
	return(h);
}


int key_compare(void *k1, void *k2) {
	//printf("in %s with %s and %s\n", __FUNCTION__, (char *) k1, (char *) k2);
	return strcmp(k1, k2);
}

void delete(void *v) {
	return;
}

Node *create_Node(enum NodeType t, void (*printNode)(struct Node *node, int parentId)) {
	Node *ret = malloc(sizeof(*ret));
	if (!ret) {
		perror("malloc");
		exit(1);
	}
	ret->nodeType = t;
	ret->printNode = printNode;
	return ret;
}

void printTree(Node *node, int parentId) {
	if (node) {
		node->printNode(node, parentId);
 	}
 	return;
 }

 void printGraphString(Node * root){
	fp = fopen("graph.txt", "w");
	fprintf(fp, "digraph G {\n");
	printTree(root, nodeId);
	fprintf(fp, "}\n");
	fflush(fp);
	fclose(fp);
}

void printNode(char *label, int myNodeId, int parentId) {
	fprintf(fp, "\t%d [label=\"%s\", shape=box];\n", myNodeId, label);

	if (parentId > 0) {
		fprintf(fp, "\t%d -> %d;\n", parentId, myNodeId);
	}
}

<% for (var key in nodeTypes) { %>
Node *create_<%- key %>(<%- nodeTypes[key].children.map(function(val){return "Node *"+val}).concat(nodeTypes[key].val.map(function(val){return val.type+" "+val.name})).join(", ") %>) {
	Node *ret = create_Node(<%- key+"_t" %>, &<%- key+"_p" %>);
	<%- nodeTypes[key].children.map(function(val){return "ret->children."+key+"."+val+" = "+val+";"}).concat(nodeTypes[key].val.map(function(val){ return "ret->children."+key+"."+val.name+"="+val.name+";"})).join("\n\t\t") %>
	return ret;
}
<% }; %>

<% for (var key in nodeTypes) { %>
void <%- key %>_p(Node * node, int parentId){
	nodeId++;
	int myNodeId = nodeId;
	int temp = 0;
	<%- nodeTypes[key].children.map(function(val){return "printTree(node->children."+key+"."+val+", myNodeId);"}).join("\n\t\t") %>
	<%- "printNode(\""+key+"\", myNodeId, parentId);" %>

	<%- nodeTypes[key].val.map(function(val){
		var cPrintSyn = "%s";
		if(val.type == "int"){
			cPrintSyn = "%d";
		}else if(val.type == "float"){
			cPrintSyn = "%f";
		}else if(val.type == "char"){
			cPrintSyn = "%c";
		}
		var top = "nodeId++;\n\ttemp = nodeId;\n\t"
		var a = 'fprintf(fp, "%d [label='+'\\"'+cPrintSyn+'\\"'+', shape=box];", temp, node->children.'+key+'.'+val.name+');\n\t'
		var b = 'fprintf(fp, "%d -> %d;", myNodeId, temp);'
		return top+a+b}) 
	%>	
};
<% }; %>

evaluatedNode * trav_node(Node * node){
	evaluatedNode * ret = calloc(sizeof(*ret), 1);
	if(node == NULL){
		return ret;
	}
	
	switch(node->nodeType){
		<% for (var key in nodeTypes) { %>
		case <%- nodeTypes[key].enumType %>:
			{
				//printf("%s\n", "<%- nodeTypes[key].enumType %>");

				<% if (key == nodeTypes.struct_def.name) {%>
					local_struct_iden_table = hash_table_create(128, delete, hash, key_compare);
				<% }; %>

				<% for (var child in nodeTypes[key].children) { var cEvNode = nodeTypes[key].children[child]+"_node" %>
					evaluatedNode * <%- cEvNode %> = trav_node(node->children.<%- nodeTypes[key].name %>.<%- nodeTypes[key].children[child] %>);
				<% }; %>

				<% if (key == nodeTypes.base_type_lit.name) {%>
					ret->strVal = node->children.base_type_lit.iden;
				<% } %>
				<% if (key == nodeTypes.type_iden.name) {%>
					cur_assign_var_decl_type = type_node->strVal;
					ret->strVal = type_node->strVal;
				<% } %>
				<% if (key == nodeTypes.identifier.name) {%>
					ret->strVal = node->children.identifier.val;
				<% } %>
				<% if (key == nodeTypes.var_name_iden.name) {%>
					ret->strVal = identifier_node->strVal;
					//if(array_decl_node){
					ret->intVal = array_decl_node->intVal;
					//}
				<% } %>
				<% if (key == nodeTypes.array_decl.name) {%>
					//printf("HERE %d\n", expr_node->intVal);
					ret->intVal = expr_node->intVal;
				<% } %>
				<% if (key == nodeTypes.type_decl.name) {%>
					//type_iden_node->strVal
					//printf("**%s\n", var_name_iden_node->strVal);
					if(hash_table_retrieve(global_type_table, var_name_iden_node->strVal)){
						printf("Duplicate types in type table cant insert %s (%s)\n", var_name_iden_node->strVal, type_iden_node->strVal);
						exit(0);
					}else{
						symbolTableType * typeRef = hash_table_retrieve(global_type_table, type_iden_node->strVal);
						if(typeRef){
							symbolTableType * type = calloc(sizeof(*type), 1);
							type->size = typeRef->size;
							type->baseType = typeRef->baseType;
							type->refType = typeRef;
							//printf("+++%d %d %d\n", var_name_iden_node->intVal, typeRef->array_size, var_name_iden_node->intVal);
							if(typeRef->array_size > 0 && var_name_iden_node->intVal > 0){
								printf("Error cannot make array of array in cflat\n");
								exit(0);
							}
							type->array_size = var_name_iden_node->intVal;
							hash_table_insert(global_type_table, var_name_iden_node->strVal, type);
						}else{
							printf("Type does not exist\n");
							exit(0);
						}
					}
					//hash_table_insert(global_type_table, 
				<% } %>
				<% if (key == nodeTypes.expr.name) {%>
					if(node->children.expr.right_expr == NULL){
						ret->type = left_expr_node->type;
						ret->intVal = left_expr_node->intVal;
						ret->floatVal = left_expr_node->floatVal;
					}
					if(operator_node->strVal)
						//printf("%s\n", operator_node->strVal);
					//printf("--%d %d\n", left_expr_node->type, right_expr_node->type);
					if (operator_node->strVal && ((strcmp(operator_node->strVal, "+") == 0) || (strcmp(operator_node->strVal, "-") == 0) || (strcmp(operator_node->strVal, "*") == 0) ||
						(strcmp(operator_node->strVal, "/") == 0))){

						if(left_expr_node->type == right_expr_node->type){
							ret->type = right_expr_node->type;
							if(ret->type == INTVAL || ret->type == CHARVAL){
								ret->intVal = left_expr_node->intVal + right_expr_node->intVal;
							}else if(ret->type == FLOATVAL){
								ret->floatVal = left_expr_node->floatVal + right_expr_node->floatVal;
							}
						}else {
							printf("Error incompadible types\n");
							exit(0);
						}
					}
				<% } %>
				<% if (key == nodeTypes.operator.name) {%>
					ret->strVal = node->children.operator.type;
				<% } %>
				<% if (key == nodeTypes.int_val.name) {%>
					ret->type = INTVAL;
					ret->intVal = node->children.int_val.val;
				<% } %>
				<% if (key == nodeTypes.float_val.name) {%>
					ret->type = FLOATVAL;
					ret->floatVal = node->children.float_val.val;
				<% } %>
				<% if (key == nodeTypes.char_val.name) {%>
					ret->type = CHARVAL;
					ret->intVal = node->children.char_val.val;
				<% } %>
				<% if (key == nodeTypes.struct_def.name) {%>
					char * structName = calloc(sizeof(*structName),100);
					sprintf(structName, "___tmp_struct_%d", structCounter++);
					symbolTableType * type = calloc(sizeof(*type), 1);
					type->size = var_list_node->intVal;
					type->structIdenTable = local_struct_iden_table;
					hash_table_insert(global_type_table, structName, type);
					ret->strVal = structName;
					local_struct_iden_table == NULL;
				<% } %>
				<% if (key == nodeTypes.assign_var_list.name) {%>
					ret->intVal = assign_var_list_node->intVal + assign_var_decl_node->intVal;
				<% } %>
				<% if (key == nodeTypes.assign_var_decl.name) {%>
					symbolTableType* temp = hash_table_retrieve(global_type_table, type_iden_node->strVal);
					int size = temp->size;
					if (temp->array_size > 0){
						size *= temp->array_size;
					}
					//printf("SIZE IS %d\n", size);
					ret->intVal = size;
				<% } %>
				<% if (key == nodeTypes.assign_var_name_iden.name) {%>
					ret->strVal = var_name_iden_node->strVal;
					if(local_struct_iden_table != NULL){
						symbolTableIden * idenTableEntry = calloc(sizeof(*idenTableEntry), 1);
						idenTableEntry->name = ret->strVal;
						idenTableEntry->type = hash_table_retrieve(global_type_table, cur_assign_var_decl_type);
						hash_table_insert(local_struct_iden_table, ret->strVal, idenTableEntry);
					}
					//TODO what do with var name iden array decl val
					//TODO what do with expr child
				<% } %>
				<% if (key == nodeTypes.var_name_iden.name) {%>
					ret->strVal = identifier_node->strVal;
					ret->intVal = array_decl_node->intVal;
				<% } %>

				

				<% for (var child in nodeTypes[key].children) { var cEvNode = nodeTypes[key].children[child]+"_node" %>
					if(<%- cEvNode %>){
						//free(<%- cEvNode %>->strVal);
						free(<%- cEvNode %>);
					}
				<% }; %>
			}
			break;
		<% }; %>
		default:
			printf("BAD NOT TYPE????");
			break;
	}
	return ret;
}