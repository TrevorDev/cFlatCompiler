//THIS FILE IS GENERATED IN proNode/nodes.jc
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define localFpOffsetStart 4
#include "nodes.h"
#include "mipsGen.h"

extern int symbolTableOutput;

extern HashTable *global_type_table;
HashTable *local_struct_iden_table;
extern HashTable *global_iden_table;
extern HashTable *local_iden_table;
extern char * codeOutput;
char * cur_assign_var_decl_type = NULL;
char * functionType = NULL;
int setFunctionType = 0;
int inGlobal = 1;
int tempCount = 0;

int localFpOffset = localFpOffsetStart;
int globalFpOffset = 4;
int VAR_SIZE = 4;


void insert_to_type_table(char * newTypeName, int array_size, char * refTypeName){
	if(hash_table_retrieve(global_type_table, newTypeName)){
		printf("Duplicate types in type table cant insert %s (%s)\n", newTypeName, refTypeName);
		exit(0);
	}
	else{
		symbolTableType * typeRef = hash_table_retrieve(global_type_table, refTypeName);
		if(typeRef){
			symbolTableType * type = calloc(sizeof(*type), 1);
			type->name = newTypeName;
			type->size = typeRef->size;
			type->baseType = typeRef->baseType;
			type->refType = typeRef;
			if(typeRef->array_size > 0 && array_size > 0){
				printf("Error cannot make array of array in cflat\n");
				exit(0);
			}
			type->array_size = array_size;
			hash_table_insert(global_type_table, newTypeName, type);
		}
		else{
			printf("Type does not exist\n");
			exit(0);
		}
	}
}

void printSymbolTableType(symbolTableType * s){
	printf("----------------\nname: %s\nsize: %d\narray size: %d\nbase type:%s\n", s->name, s->size, s->array_size, s->baseType);
}

void printSymbolTableIden(symbolTableIden *s)
{
	printf("----------------\nname: %s\narray size: %d\ntype: %s\nFP offset: %d\nis func: %d\nis param:%d\n", s->name, s->arraySize, s->type->name, s->fpOffset, s->isFunc, s->isParam);
	if(s->isFunc){
		printf("params: ");
		functionArgs * itr = s->args;
		while(itr){
			printf("%s %s, ", itr->iden->type->name, itr->iden->name);
			itr = itr->next;
		}
		printf("\n");
	}
}

void printTypeTable(HashTable *h)
{
	symbolTableType *foo;
	foo = hash_table_retrieve_after(h, NULL);
	if (foo) {
		printSymbolTableType(foo);
	}
	while (foo) {
		foo = hash_table_retrieve_after(h, foo);
		if (foo) {
			printSymbolTableType(foo);
		}
	}
}

void printSymbolTable(HashTable *h)
{
	symbolTableIden *foo2 = hash_table_retrieve_after(h, NULL);
	if (foo2) {
		printf("New Iden Table\n");		
		printSymbolTableIden(foo2);
	}
	while (foo2) {
		foo2 = hash_table_retrieve_after(h, foo2);
		if (foo2) {
			printSymbolTableIden(foo2);
		}
	}
}


int nodeId = 0;
FILE* fp;
int structCounter = 0;



int insert_symbol_table_iden_entry(char * name, int arraySize, int isFunc, int isParam, functionArgs * args, char * type){
	if(!isFunc && strcmp(type, "void") == 0){
		printf("Non function %s cannot have type void\n", name);
		exit(0);
	}
	HashTable * tableToUse = NULL;
	if(local_iden_table && !isFunc){
		tableToUse = local_iden_table;
	}
	else{
		//printf("global\n");
		tableToUse = global_iden_table;
	}
	
	if (!hash_table_retrieve(tableToUse, name)){
		symbolTableIden * data = calloc(sizeof(*data), 1);
		symbolTableType * typeRef = hash_table_retrieve(global_type_table, type);
		if(!typeRef){
			printf("Invalid type '%s' for identifier '%s'\n", type, name);
			exit(0);
		}
		data->name = name;
		data->type = typeRef;
		data->isFunc = isFunc;
		data->args = args;
		data->isParam = isParam;
		data->arraySize = arraySize > 0 ? arraySize : typeRef->array_size;
		if(arraySize > 0 && typeRef->array_size > 0){
			printf("Multi dimensional arrays not supported\n");
			exit(0);
		} 
		if(data->type){
			if(!isFunc){

				int offset = (arraySize == 0) ? typeRef->size : typeRef->size * arraySize;
				char * pType = "sp";
				if(local_iden_table){
					data->fpOffset = localFpOffset;
					localFpOffset += offset;
				}else{
					pType = "gp";
					data->fpOffset = globalFpOffset;
					globalFpOffset += offset;
				}
				append_assembler("#push stack pointer forward for var %s", data->name);
				append_assembler("sub     $sp,$sp,%d", offset);
			}
			hash_table_insert(tableToUse, name, data);
		}
		else{
			printf("The type %s does not exist\n", (char*) type);
			exit(0);
		}
	}
	else{
		printf("%s identifier already exists\n", (char*) name);
		exit(0);
	}

	return 0;
}

symbolTableIden *retrieve_symbol_table_iden_entry(char *key){
	symbolTableIden * ret = NULL;
	if(local_iden_table) {
		ret = hash_table_retrieve(local_iden_table, key);
	}

	if (!ret) {
		ret = hash_table_retrieve(global_iden_table, key);
	}
	
	return ret;
}

void setIdenValue(char * name, int intVal, float floatVal){
	symbolTableIden * iden = retrieve_symbol_table_iden_entry(name);

	if (strcmp(iden->type->baseType, "float") == 0) {
		append_assembler("li.s	$f0,%f", floatVal);
		append_assembler("s.s	$f0, -%d(%s)", iden->fpOffset, hash_table_retrieve(local_iden_table, name) ? "$fp" : "$gp");
	}
	else{
		append_assembler("li	$a0,%d", intVal);
		append_assembler("sw	$a0, -%d(%s)", iden->fpOffset, hash_table_retrieve(local_iden_table, name) ? "$fp" : "$gp");
	}
}

void setIdenValueToIdenVal(char * dest, char * src){
	//printf("%s HERERERE\n", src);
	symbolTableIden * idenDest = retrieve_symbol_table_iden_entry(dest);
	symbolTableIden * idenSrc = retrieve_symbol_table_iden_entry(src);
	append_assembler("lw	$a0,-%d(%s)\t#load %s variable %s to register $a0",
	  idenSrc->fpOffset, hash_table_retrieve(local_iden_table, src) ? "$fp" : "$gp",
	  hash_table_retrieve(local_iden_table, src) ? "local" : "global", src);

	append_assembler("sw	$a0, -%d(%s)\t#store variable %s in %s variable %s",
	  idenDest->fpOffset, hash_table_retrieve(local_iden_table, dest) ? "$fp" : "$gp",
	  src, hash_table_retrieve(local_iden_table, dest) ? "local" : "global", dest);
}

void setIdenFromReg(char *dest, char *reg, int type)
{
	symbolTableIden *idenDest = retrieve_symbol_table_iden_entry(dest);
	if (type == FLOATVAL){
		append_assembler("s.s	%s, -%d(%s)\t#store variable %s in %s variable %s", reg,
			idenDest->fpOffset, hash_table_retrieve(local_iden_table, dest) ? "$fp" : "$gp",
			dest, hash_table_retrieve(local_iden_table, dest) ? "local" : "global", dest);
	}
	else{
		append_assembler("sw	%s, -%d(%s)\t#store variable %s in %s variable %s", reg,
			idenDest->fpOffset, hash_table_retrieve(local_iden_table, dest) ? "$fp" : "$gp",
			dest, hash_table_retrieve(local_iden_table, dest) ? "local" : "global", dest);
	}

}



int baseTypeToEnum(char * type){
	int ret = 0;
	
	if (strcmp(type, "char") == 0) {
		return CHARVAL;
	}
	else if (strcmp(type, "int") == 0) {
		return INTVAL;
	}
	else if (strcmp(type, "float") == 0) {
		return FLOATVAL;
	}
	else if (strcmp(type, "void") == 0) {
		return NONEVAL;
	}
	else {
		symbolTableType * typeRef = hash_table_retrieve(global_type_table, type);
		if (!typeRef){
			return -1;
		}
		return baseTypeToEnum(typeRef->baseType);
	}

	return ret;
}

unsigned int hash (void *v)
{
	char *s0 = v;
	unsigned int h=0;
	char *s;
	for (s = s0; *s; s++) {
		h = h*65599 + *s;
	}
	
	return(h);
}


int key_compare(void *k1, void *k2) {
	//printf("in %s with %s and %s\n", __FUNCTION__, (char *) k1, (char *) k2);
	return strcmp(k1, k2);
}

void delete(void *v) {
	return;
}

Node *create_Node(enum NodeType t, void (*printNode)(struct Node *node, int parentId)) {
	Node *ret = malloc(sizeof(*ret));
	if (!ret) {
		perror("malloc");
		exit(1);
	}
	ret->nodeType = t;
	ret->printNode = printNode;
	return ret;
}

void printTree(Node *node, int parentId) {
	if (node) {
		node->printNode(node, parentId);
 	}
 	return;
 }

 void printGraphString(Node * root){
	fp = fopen("graph.txt", "w");
	fprintf(fp, "digraph G {\n");
	printTree(root, nodeId);
	fprintf(fp, "}\n");
	fflush(fp);
	fclose(fp);
}

void printNode(char *label, int myNodeId, int parentId) {
	fprintf(fp, "\t%d [label=\"%s\", shape=box];\n", myNodeId, label);

	if (parentId > 0) {
		fprintf(fp, "\t%d -> %d;\n", parentId, myNodeId);
	}
}

char *new_iden(int type)
{
	char buf[20];
	sprintf(buf, "___temp%d",tempCount++);
	char *name = strdup(buf);
	
	insert_symbol_table_iden_entry(name, 0, 0, 0, NULL, type == INTVAL ? "int" : (type == CHARVAL ? "char" : "float"));
	return name;
}

void load_arguments(char *leftArg, char *rightArg, int type)
{
	symbolTableIden *leftIden = NULL, *rightIden = NULL;
	if (leftArg) {
		leftIden = retrieve_symbol_table_iden_entry(leftArg);
		if (type == FLOATVAL){
			append_assembler("l.s	$f0,-%d(%s)\t#load %s variable %s to register $f0",
	  			leftIden->fpOffset, hash_table_retrieve(local_iden_table, leftIden->name) ? "$fp" : "$gp",
	    		hash_table_retrieve(local_iden_table, leftIden) ? "local" : "global", leftIden->name);
		}
		else{
			append_assembler("lw	$a0,-%d(%s)\t#load %s variable %s to register $a0",
	  			leftIden->fpOffset, hash_table_retrieve(local_iden_table, leftIden->name) ? "$fp" : "$gp",
	    		hash_table_retrieve(local_iden_table, leftIden) ? "local" : "global", leftIden->name);
		}

	}
	if (rightArg) {
		rightIden = retrieve_symbol_table_iden_entry(rightArg);
		if (type == FLOATVAL){
			append_assembler("l.s	$f1,-%d(%s)\t#load %s variable %s to register $f1",
		      rightIden->fpOffset, hash_table_retrieve(local_iden_table, rightIden->name) ? "$fp" : "$gp",
		      hash_table_retrieve(local_iden_table, rightIden) ? "local" : "global", rightIden->name);
		}
		else{
			append_assembler("lw	$a1,-%d(%s)\t#load %s variable %s to register $a1",
	    		rightIden->fpOffset, hash_table_retrieve(local_iden_table, rightIden->name) ? "$fp" : "$gp",
	    		hash_table_retrieve(local_iden_table, rightIden) ? "local" : "global", rightIden->name);
		}

	}	
}

<% for (var key in nodeTypes) { %>
Node *create_<%- key %>(<%- nodeTypes[key].children.map(function(val){return "Node *"+val}).concat(nodeTypes[key].val.map(function(val){return val.type+" "+val.name})).join(", ") %>) {
	Node *ret = create_Node(<%- key+"_t" %>, &<%- key+"_p" %>);
	<%- nodeTypes[key].children.map(function(val){return "ret->children."+key+"."+val+" = "+val+";"}).concat(nodeTypes[key].val.map(function(val){ return "ret->children."+key+"."+val.name+"="+val.name+";"})).join("\n\t\t") %>
	return ret;
}
<% }; %>

<% for (var key in nodeTypes) { %>
void <%- key %>_p(Node * node, int parentId){
	nodeId++;
	int myNodeId = nodeId;
	int temp = 0;
	<%- nodeTypes[key].children.map(function(val){return "printTree(node->children."+key+"."+val+", myNodeId);"}).join("\n\t\t") %>
	<%- "printNode(\""+key+"\", myNodeId, parentId);" %>

	<%- nodeTypes[key].val.map(function(val){
		var cPrintSyn = "%s";
		if(val.type == "int"){
			cPrintSyn = "%d";
		}
		else if(val.type == "float"){
			cPrintSyn = "%f";
		}
		else if(val.type == "char"){
			cPrintSyn = "%c";
		}
		var top = "nodeId++;\n\ttemp = nodeId;\n\t"
		var a = 'fprintf(fp, "%d [label='+'\\"'+cPrintSyn+'\\"'+', shape=box];", temp, node->children.'+key+'.'+val.name+');\n\t'
		var b = 'fprintf(fp, "%d -> %d;", myNodeId, temp);'
		return top+a+b}) 
	%>	
};
<% }; %>

evaluatedNode * trav_node(Node * node){
	evaluatedNode * ret = calloc(sizeof(*ret), 1);
	if(node == NULL){
		return ret;
	}
	
	switch(node->nodeType){
		<% for (var key in nodeTypes) { %>
		case <%- nodeTypes[key].enumType %>:
			{
				// PRE RECURSION
				<% if (key == nodeTypes.struct_def.name) {%>
					local_struct_iden_table = hash_table_create(128, delete, hash, key_compare);
				<% }; %>

				<% if (key == nodeTypes.function_def.name) {%>
					if(inGlobal){
						append_assembler("#frame pointer push for func call");
						append_assembler("sub     $sp,$sp,4");
						append_assembler("sw      $fp,4($sp)");
						append_assembler("jal     __main");
						append_assembler("lw      $ra, 0($fp)");
						append_assembler("lw      $fp, 4($fp)");
						append_assembler("jr		$ra");
					}
					inGlobal = 0;
					local_iden_table = hash_table_create(128, delete, hash, key_compare);
					localFpOffset = localFpOffsetStart;
					evaluatedNode * iden_node = trav_node(node->children.function_def.iden);
					char * asmFuncName = iden_node->strVal;
					if(strcmp(asmFuncName, "main") == 0){
						asmFuncName = "__main";
					}
					append_assembler("\n\n%s:", asmFuncName);
					append_assembler("#setup framepointer and save ra");
					append_assembler("move    $fp,$sp");
					append_assembler("sub     $sp,$sp,4");
					append_assembler("sw      $ra,4($sp)");
    
					evaluatedNode * param_list_node = trav_node(node->children.function_def.param_list);
					insert_symbol_table_iden_entry(iden_node->strVal, 0, 1, 0, param_list_node->params, functionType);
					evaluatedNode * function_body_node = trav_node(node->children.function_def.function_body);

					 
				    

				    
					append_assembler("#reset sp and fp and return");
					append_assembler("move    $sp,$fp");
					append_assembler("lw      $ra, 0($fp)");
					append_assembler("lw      $fp, 4($fp)");
					append_assembler("jr      $ra");
				<% }; %>

				<% if (key == nodeTypes.assign_var_decl.name) {%>
					if(node->children.assign_var_decl.comma_iden_assign_list->nodeType == function_def_t){
						setFunctionType = 1;
					}
				<% }; %>
				
				<% for (var child in nodeTypes[key].children) { var cEvNode = nodeTypes[key].children[child]+"_node" %>
					<% if(key != nodeTypes.function_def.name){ %>
						evaluatedNode * <%- cEvNode %> = trav_node(node->children.<%- nodeTypes[key].name %>.<%- nodeTypes[key].children[child] %>);
					<% } %>
				<% }; %>
				//POST RECURSION
				<% if (key == nodeTypes.base_type_lit.name) {%>
					ret->strVal = node->children.base_type_lit.iden;
				<% } %>
				<% if (key == nodeTypes.type_iden.name) {%>
					if(setFunctionType){
						functionType = type_node->strVal;
						setFunctionType = 0;
					}else{
						cur_assign_var_decl_type = type_node->strVal;
					}
					
					ret->strVal = type_node->strVal;
				<% } %>
				<% if (key == nodeTypes.identifier.name) {%>
					ret->strVal = node->children.identifier.val;
				<% } %>
				<% if (key == nodeTypes.var_name_iden.name) {%>
					ret->strVal = identifier_node->strVal;
					if (array_decl_node->deferEval){
						printf("Cannot define variable length array for '%s'\n", identifier_node->strVal);
						exit(0);
					}
					ret->intVal = array_decl_node->intVal;

				<% } %>
				<% if (key == nodeTypes.array_decl.name) {%>
					if (expr_node->type != INTVAL){
						printf("Array size must be integer value\n");
						exit(0);
					}
					ret->intVal = expr_node->intVal;
					ret->deferEval = expr_node->deferEval;
				<% } %>
				<% if (key == nodeTypes.type_decl.name) {%>
					insert_to_type_table(var_name_iden_node->strVal, var_name_iden_node->intVal, type_iden_node->strVal);
				<% } %>
				<% if (key == nodeTypes.expr.name) {%>
					//SINGLE VAR/NUMBER/CHAR
					if(node->children.expr.right_expr == NULL && node->children.expr.operator == NULL){


						
						ret->type = left_expr_node->type;
						ret->intVal = left_expr_node->intVal;
						ret->floatVal = left_expr_node->floatVal;
						if(node->children.expr.left_expr->nodeType == variable_t){
							//symbolTableIden * iden = retr
							ret->isArray = left_expr_node->isArray;
						}
						if(node->children.expr.left_expr->nodeType == int_val_t || node->children.expr.left_expr->nodeType == float_val_t || node->children.expr.left_expr->nodeType == char_val_t){
							char *name = new_iden(ret->type);
							ret->strVal = name;
							setIdenValue(name, left_expr_node->intVal, left_expr_node->floatVal);
						}
						else{
							printf("<<<<<<<<< %s %d\n", left_expr_node->strVal, node->children.expr.left_expr->nodeType);
							ret->strVal = left_expr_node->strVal;
						}

					}
					else{
						if(left_expr_node->isArray || right_expr_node->isArray){
							printf("Cannot use operator on array\n");
							exit(0);
						}
						if(node->children.expr.operator &&  node->children.expr.right_expr && node->children.expr.left_expr == NULL){
							//UNARY + - -- ++ on left side
							ret->type = right_expr_node->type;
							ret->intVal = right_expr_node->intVal;
							ret->floatVal = right_expr_node->floatVal;
							ret->type = right_expr_node->type;
							if(operator_node->strVal){
								if(strcmp(operator_node->strVal, "+") == 0){

								}else if(strcmp(operator_node->strVal, "-") == 0){
									ret->floatVal = -ret->floatVal;
									ret->intVal = -ret->intVal;
								}else if(strcmp(operator_node->strVal, "++") == 0){
									if(!right_expr_node->isVar){
										printf("Cannot use ++/-- on non var\n");
										exit(0);
									}
									ret->floatVal = ret->floatVal+1;
									ret->intVal = ret->intVal+1;
								}else if(strcmp(operator_node->strVal, "--") == 0){
									if(!right_expr_node->isVar){
										printf("Cannot use ++/-- on non var\n");
										exit(0);
									}
									ret->floatVal = ret->floatVal-1;
									ret->intVal = ret->intVal-1;
								}
							}
						}else if(node->children.expr.operator &&  node->children.expr.right_expr == NULL && node->children.expr.left_expr){
							ret->type = left_expr_node->type;
							ret->intVal = left_expr_node->intVal;
							ret->floatVal = left_expr_node->floatVal;
							ret->type = left_expr_node->type;
							if(operator_node->strVal){
								if(strcmp(operator_node->strVal, "+") == 0){

								}else if(strcmp(operator_node->strVal, "-") == 0){

								}else if(strcmp(operator_node->strVal, "++") == 0){
									if(!left_expr_node->isVar){
										printf("Cannot use ++/-- on non var\n");
										exit(0);
									}
								}else if(strcmp(operator_node->strVal, "--") == 0){
									if(!left_expr_node->isVar){
										printf("Cannot use ++/-- on non var\n");
										exit(0);
									}
								}
							}
						}else{ // binary operation
							ret->type = left_expr_node->type;
							ret->intVal = left_expr_node->intVal;
							ret->floatVal = left_expr_node->floatVal;
							ret->type = left_expr_node->type;
							if (node->children.expr.right_expr){
								ret->deferEval = (ret->deferEval || right_expr_node->deferEval);
							}

							if (node->children.expr.left_expr){
								ret->deferEval = (ret->deferEval || left_expr_node->deferEval);
							}

							if (operator_node->strVal && ((strcmp(operator_node->strVal, "+") == 0) || (strcmp(operator_node->strVal, "-") == 0) || (strcmp(operator_node->strVal, "*") == 0) ||
								(strcmp(operator_node->strVal, "/") == 0 || !strcmp(operator_node->strVal, ">") || !strcmp(operator_node->strVal, "<") || !strcmp(operator_node->strVal, "==") ||
								!strcmp(operator_node->strVal, "!=") || !strcmp(operator_node->strVal, ">=") || !strcmp(operator_node->strVal, "<=")))){

								if(left_expr_node->type != right_expr_node->type){
									printf("Expression contains incompatible types\n");
									exit(0);
								}
								ret->type = right_expr_node->type;

								char * tempVar = new_iden(ret->type);
								ret->strVal = tempVar;

								if (strcmp(operator_node->strVal, "+") == 0) {
									if(ret->type == INTVAL || ret->type == CHARVAL){
										ret->intVal = left_expr_node->intVal + right_expr_node->intVal;

										load_arguments(left_expr_node->strVal, right_expr_node->strVal, INTVAL);
										append_assembler("add $a0,$a0,$a1");
										setIdenFromReg(tempVar, "$a0", INTVAL);

									}
									else if(ret->type == FLOATVAL){
										ret->floatVal = left_expr_node->floatVal + right_expr_node->floatVal;
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, FLOATVAL);
										append_assembler("add.s $f0,$f0,$f1");
										setIdenFromReg(tempVar, "$f0", FLOATVAL);
									}	
								}
								else if (strcmp(operator_node->strVal, "-") == 0){
									if(ret->type == INTVAL || ret->type == CHARVAL){
										ret->intVal = left_expr_node->intVal - right_expr_node->intVal;

										load_arguments(left_expr_node->strVal, right_expr_node->strVal, INTVAL);
										append_assembler("sub $a0,$a0,$a1");
										setIdenFromReg(tempVar, "$a0", INTVAL);
									}
									else if(ret->type == FLOATVAL){
										ret->floatVal = left_expr_node->floatVal - right_expr_node->floatVal;
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, FLOATVAL);
										append_assembler("sub.s $f0,$f0,$f1");
										setIdenFromReg(tempVar, "$f0", FLOATVAL);
									}
								}
								else if (strcmp(operator_node->strVal, "*") == 0){
									if(ret->type == INTVAL || ret->type == CHARVAL){
										ret->intVal = left_expr_node->intVal * right_expr_node->intVal;

										load_arguments(left_expr_node->strVal, right_expr_node->strVal, INTVAL);
										append_assembler("mult $a0,$a1");
										append_assembler("mflo $a0");
										setIdenFromReg(tempVar, "$a0", INTVAL);
									}
									else if(ret->type == FLOATVAL){
										ret->floatVal = left_expr_node->floatVal * right_expr_node->floatVal;
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, FLOATVAL);
										append_assembler("mul.s $f0,$f0,$f1");
										setIdenFromReg(tempVar, "$f0", FLOATVAL);
									}
								}
								else if (strcmp(operator_node->strVal, "/") == 0){
									if(ret->type == INTVAL || ret->type == CHARVAL){
										// TODO: FIX DIVISION - CURRENTLY GET A RUNTIME EXCEPTION OF DIVIDE BY 0!!!
										if (right_expr_node->intVal == 0){
											right_expr_node->intVal = 1;
										}
										ret->intVal = left_expr_node->intVal / right_expr_node->intVal;
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, INTVAL);
										append_assembler("div $a0,$a1");
										append_assembler("mflo $a0");
										setIdenFromReg(tempVar, "$a0", INTVAL);
									}
									else if(ret->type == FLOATVAL){
										if (right_expr_node->floatVal == 0.0){
											right_expr_node->floatVal = 1.0;
										}
										ret->floatVal = left_expr_node->floatVal / right_expr_node->floatVal;
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, FLOATVAL);
										append_assembler("div.s $f0,$f0,$f1");
										setIdenFromReg(tempVar, "$f0", FLOATVAL);
										//
									}
								}
								else if (strcmp(operator_node->strVal, "<") == 0) {
									if (ret->type == INTVAL || ret->type == CHARVAL) {
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, INTVAL);
										append_assembler("slt $a0,$a0,$a1");
										setIdenFromReg(tempVar, "$a0", INTVAL);
									}
									else if (ret->type == FLOATVAL) {

									}
								}
								else if (strcmp(operator_node->strVal, ">") == 0) {
									if (ret->type == INTVAL || ret->type == CHARVAL) {
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, INTVAL);
										append_assembler("slt $a0,$a1,$a0");
										setIdenFromReg(tempVar, "$a0", INTVAL);
									}
									else if (ret->type == FLOATVAL) {

									}
								}
								else if (!strcmp(operator_node->strVal, "==")) {
									if (ret->type == INTVAL || ret->type == CHARVAL) {
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, INTVAL);
										append_assembler("subu $t2,$a0,$a1");
										append_assembler("sltu $t2,$zero,$t2");
										append_assembler("xori $t2, $t2, 1");
										setIdenFromReg(tempVar, "$t2", INTVAL);
									}
									else if (ret->type == FLOATVAL) {

									}
								}
								else if (!strcmp(operator_node->strVal, "!=")) {
									if (ret->type == INTVAL || ret->type == CHARVAL) {
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, INTVAL);
										append_assembler("subu $t2,$a0,$a1");
										append_assembler("sltu $t2,$zero,$t2");
										//append_assembler("xori $t2, $t2, 1");
										setIdenFromReg(tempVar, "$t2", INTVAL);
									}
									else if (ret->type == FLOATVAL) {

									}
								}
								else if (!strcmp(operator_node->strVal, ">=")) {
									if (ret->type == INTVAL || ret->type == CHARVAL) {
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, INTVAL);
										append_assembler("sge $a0,$a0,$a1");
										//append_assembler("sltu $t2,$zero,$t2");
										//append_assembler("xori $t2, $t2, 1");
										setIdenFromReg(tempVar, "$a0", INTVAL);
									}
									else if (ret->type == FLOATVAL) {

									}
								}
								else if (!strcmp(operator_node->strVal, "<=")) {
									if (ret->type == INTVAL || ret->type == CHARVAL) {
										load_arguments(left_expr_node->strVal, right_expr_node->strVal, INTVAL);
										append_assembler("sle $a0,$a0,$a1");
										//append_assembler("sltu $t2,$zero,$t2");
										//append_assembler("xori $t2, $t2, 1");
										setIdenFromReg(tempVar, "$a0", INTVAL);
									}
									else if (ret->type == FLOATVAL) {

									}
								}

							}
							else if(!operator_node->strVal){
								//expr only evaluates to array if there is no operator on an array
								ret->isArray = left_expr_node->isArray;
								//TODO cause error when operator is performed on array
							}
						}
					}
					
				<% } %>
				<% if (key == nodeTypes.operator.name) {%>
					ret->strVal = node->children.operator.type;
				<% } %>
				<% if (key == nodeTypes.int_val.name) {%>
					ret->type = INTVAL;
					ret->intVal = node->children.int_val.val;
				<% } %>
				<% if (key == nodeTypes.float_val.name) {%>
					ret->type = FLOATVAL;
					ret->floatVal = node->children.float_val.val;
				<% } %>
				<% if (key == nodeTypes.char_val.name) {%>
					ret->type = CHARVAL;
					ret->intVal = node->children.char_val.val;
				<% } %>
				<% if (key == nodeTypes.struct_def.name) {%>
					printf("Structs not supported\n");
					exit(0);
				<% } %>
				<% if (key == nodeTypes.assign_var_list.name) {%>
					ret->intVal = assign_var_list_node->intVal + assign_var_decl_node->intVal;
				<% } %>
				<% if (key == nodeTypes.assign_var_decl.name) {%>
					symbolTableType* temp = hash_table_retrieve(global_type_table, type_iden_node->strVal);
					int size = temp->size;
					if (temp->array_size > 0){
						size *= temp->array_size;
					}
					//printf("SIZE IS %d\n", size);
					ret->intVal = size;
				<% } %>
				<% if (key == nodeTypes.assign_var_name_iden.name) {%>
					ret->strVal = var_name_iden_node->strVal;

					insert_symbol_table_iden_entry(var_name_iden_node->strVal, var_name_iden_node->intVal, 0, 0, NULL,cur_assign_var_decl_type);
					if(node->children.assign_var_name_iden.expr && expr_node->type != baseTypeToEnum(cur_assign_var_decl_type)){
						printf("Type mismatch in variable decleration assignment\n");
						exit(0);
					}
					//TODO what do with var name iden array decl val
					//TODO what do with expr child
				<% } %>
				<% if (key == nodeTypes.variable.name) {%>
					symbolTableIden *tableIden = retrieve_symbol_table_iden_entry(variable_node->strVal);
					if (!tableIden){
						printf("Variable '%s' not declared\n", variable_node->strVal);
						exit(0);
					}
					symbolTableType * typeRef = tableIden->type;
					ret->isArray = tableIden->arraySize;
					if (strcmp( typeRef->baseType, "char") == 0){
						ret->type = CHARVAL;
					}
					else if (strcmp( typeRef->baseType, "int") == 0){
						ret->type = INTVAL;
					}
					else if (strcmp( typeRef->baseType, "float") == 0){
						ret->type = FLOATVAL;
					}
					ret->strVal = variable_node->strVal;
					ret->isVar = 1;
					ret->deferEval = 1; // Encountered a variable - cannot evaluate expression now
				<% } %>
				<% if (key == nodeTypes.non_rec_variable.name) {%>
					symbolTableIden *tableIden = retrieve_symbol_table_iden_entry(iden_node->strVal);
					// if (!node->children.non_rec_variable.array_decl && tableIden && tableIden->arraySize){
					// 	printf("Missing array index for variable '%s'\n", iden_node->strVal);
					// 	exit(0);
					// }
					ret->intVal = array_decl_node->intVal;
					ret->strVal = iden_node->strVal;
				<% } %>
				<% if (key == nodeTypes.function_def.name) {%>
					printf("Function %s\n\n", iden_node->strVal);
					printSymbolTable(local_iden_table);
					hash_table_destroy(local_iden_table);
					local_iden_table = NULL;
				<% } %>

				<% if (key == nodeTypes.assignment.name) {%>
					if (variable_node->type != expr_node->type){
						printf("Cannot assign incompatible types\n");
						exit(0);
					}
					
					if(expr_node->strVal){
						//DO THIS FOR RUNTIME EXPR
						setIdenValueToIdenVal(variable_node->strVal, expr_node->strVal);
					}

					switch (expr_node->type){
						case CHARVAL:
						case INTVAL:
							ret->intVal = expr_node->intVal;
							break;
						case FLOATVAL:
							ret->floatVal = expr_node->floatVal;
					}
					ret->type = variable_node->type;
				<% } %>


				<% if (key == nodeTypes.function_call.name) {%>

					

					if (strcmp(iden_node->strVal, "sizeof") == 0 || strcmp(iden_node->strVal, "putc") == 0 || strcmp(iden_node->strVal, "puti") == 0 || strcmp(iden_node->strVal, "putf") == 0){
						functionArgs * givenParamIter = expr_list_node->params;
						if ((!givenParamIter) || givenParamIter->next){
							printf("Invalid use of %s() operator\n", iden_node->strVal);
							exit(0);
						}

						if(strcmp(iden_node->strVal, "putc") == 0){
							if(givenParamIter->type != CHARVAL){
								printf("Invalid use of %s() operator\n", iden_node->strVal);
								exit(0);
							}
						}else if(strcmp(iden_node->strVal, "puti") == 0){
							if(givenParamIter->type != INTVAL){
								printf("Invalid use of %s() operator\n", iden_node->strVal);
								exit(0);
							}
						}else if(strcmp(iden_node->strVal, "putf") == 0){
							if(givenParamIter->type != FLOATVAL){
								printf("Invalid use of %s() operator\n", iden_node->strVal);
								exit(0);
							}
						}else if(strcmp(iden_node->strVal, "sizeof") == 0){
							ret->type = INTVAL;
						}

						//TODO inlice putc etc
						if(strcmp(iden_node->strVal, "puti")==0){
							append_assembler("#Inline puti");
							append_assembler("lw      $a0,-%d(%s)", givenParamIter->iden->fpOffset, hash_table_retrieve(local_iden_table, givenParamIter->iden->name) ? "$fp" : "$gp");
							append_assembler("li      $v0, 1");
							append_assembler("syscall");
						}
						if(strcmp(iden_node->strVal, "putf")==0){
							append_assembler("#Inline putc");
							append_assembler("l.s      $f12,-%d(%s)", givenParamIter->iden->fpOffset, hash_table_retrieve(local_iden_table, givenParamIter->iden->name) ? "$fp" : "$gp");
							append_assembler("li      $v0, 2");
							append_assembler("syscall");
						}
						if(strcmp(iden_node->strVal, "putc")==0){
							append_assembler("#Inline putf");
							append_assembler("lw      $a0,-%d(%s)", givenParamIter->iden->fpOffset, hash_table_retrieve(local_iden_table, givenParamIter->iden->name) ? "$fp" : "$gp");
							append_assembler("li      $v0, 11");
							append_assembler("syscall");
						}
					}else{
						append_assembler("#frame pointer push for func call");
						append_assembler("sub     $sp,$sp,4");
						append_assembler("sw      $fp,4($sp)");
						append_assembler("#store the stack pointer as it is now");
						append_assembler("move $k0,$sp");
						append_assembler("sub     $sp,$sp,4");

						symbolTableIden *funcIden;funcIden = retrieve_symbol_table_iden_entry(iden_node->strVal);

						if(!funcIden){
							printf("Function '%s' does not exitst\n", iden_node->strVal);
							exit(0);
						}
						functionArgs * givenParamIter = expr_list_node->params;
						functionArgs * paramIter = funcIden->args;
						while(givenParamIter || paramIter){
							if(paramIter && !givenParamIter){
								printf("Less parameters given than expected for function '%s' call\n", iden_node->strVal);
								exit(0);
							}
							else if(givenParamIter && !paramIter){
								printf("More parameters given than expected for function '%s' call\n", iden_node->strVal);
								exit(0);
							}
							if(((givenParamIter->isArray > 0) != (paramIter->iden->arraySize > 0))|| givenParamIter->type != baseTypeToEnum(paramIter->iden->type->baseType)){
								printf("Given parameter type does not match expected type for function '%s' call\n", iden_node->strVal);
								exit(0);
							}
							givenParamIter = givenParamIter->next;
							paramIter = paramIter->next;
						}

						//store values of parameters in next stack frame
						givenParamIter = expr_list_node->params;
						while (givenParamIter) {
							int argSize;
							printf("%p, %p\n", givenParamIter, givenParamIter->iden);
							argSize = givenParamIter->iden->type->size;

							if (givenParamIter->iden->arraySize != 0) {
								argSize *= givenParamIter->iden->arraySize;
							}

							// TODO: push array values onto stack

							append_assembler("sub     $sp,$sp,%d", argSize);

							append_assembler("lw	$a0,-%d(%s)", givenParamIter->iden->fpOffset,
							  hash_table_retrieve(local_iden_table, givenParamIter->iden->name) ? "$fp" : "$gp");
							append_assembler("sw 	$a0,4($sp)");
							givenParamIter = givenParamIter->next;
						}

						if (!funcIden){
							printf("Function '%s' not defined\n", iden_node->strVal);
							exit(0);
						}

						symbolTableType *funcType = funcIden->type;
						ret->type = baseTypeToEnum(funcType->baseType);
						ret->deferEval = 1; // Encountered a variable - cannot evaluate expression now

						append_assembler("move $sp,$k0 #restore stack pointer");
						append_assembler("jal		%s", iden_node->strVal);
					}					

				<% } %>

				<% if (key == nodeTypes.param_list.name) {%>
					ret->params = calloc(sizeof(*(ret->params)), 1);
					if(param_list_node->params){
						ret->params->next = param_list_node->params;
					}
					ret->params->iden = retrieve_symbol_table_iden_entry(param_node->strVal);
					// if(ret->params->iden){
					// 	ret->params->isArray = ret->params->iden->arraySize > 0;
					// }
				<% }; %>
				<% if (key == nodeTypes.param.name) {%>
					ret->strVal = iden_node->strVal;
					insert_symbol_table_iden_entry(iden_node->strVal, iden_node->intVal, 0, 1, NULL,type_iden_node->strVal);
				<% }; %>
				<% if (key == nodeTypes.comma_expr_list.name) {%>
					ret->params = calloc(sizeof(*(ret->params)), 1);
					if(comma_expr_list_node->params){
						ret->params->next = comma_expr_list_node->params;
					}
					ret->params->type = expr_node->type;
					ret->params->isArray = expr_node->isArray;
					ret->params->iden = retrieve_symbol_table_iden_entry(expr_node->strVal);
				<% }; %>
				<% if (key == nodeTypes.return_stmt.name) {%>
					if (expr_node->type != baseTypeToEnum(functionType)){
						printf("Return type '%d' does not match expected return type '%s'\n", expr_node->type, functionType);
						exit(0);
					}
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>

				<% for (var child in nodeTypes[key].children) { var cEvNode = nodeTypes[key].children[child]+"_node" %>
					if(<%- cEvNode %>){
						//free(<%- cEvNode %>->strVal);
						free(<%- cEvNode %>);
					}
				<% }; %>
			}
			break;
		<% }; %>
		default:
			printf("SHOULDN'T BE HERE\n");
			break;
	}
	return ret;
}