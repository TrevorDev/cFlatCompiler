//THIS FILE IS GENERATED IN proNode/nodes.jc
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "nodes.h"

extern HashTable *global_type_table;
HashTable *local_struct_iden_table;
extern HashTable *global_iden_table;
extern HashTable *local_iden_table;
char * cur_assign_var_decl_type = NULL;

void insert_to_type_table(char * newTypeName, int array_size, char * refTypeName){
	if(hash_table_retrieve(global_type_table, newTypeName)){
		printf("Duplicate types in type table cant insert %s (%s)\n", newTypeName, refTypeName);
		exit(0);
	}else{
		symbolTableType * typeRef = hash_table_retrieve(global_type_table, refTypeName);
		if(typeRef){
			symbolTableType * type = calloc(sizeof(*type), 1);
			type->name = newTypeName;
			type->size = typeRef->size;
			type->baseType = typeRef->baseType;
			type->refType = typeRef;
			if(typeRef->array_size > 0 && array_size > 0){
				printf("Error cannot make array of array in cflat\n");
				exit(0);
			}
			type->array_size = array_size;
			hash_table_insert(global_type_table, newTypeName, type);
		}else{
			printf("Type does not exist\n");
			exit(0);
		}
	}
}

void printSymbolTableType(symbolTableType * s){
	printf("----------------\nname: %s\nsize: %d\narray size: %d\nbase type:%s\n", s->name, s->size, s->array_size, s->baseType);
}

void printSymbolTableIden(symbolTableIden *s)
{
	printf("----------------\nname: %s\ntype: %s\n", s->name, s->type->name);
}

int nodeId = 0;
FILE* fp;
int structCounter = 0;

int insert_symbol_table_iden_entry(char * name, int arraySize, char * type){

	HashTable * tableToUse = NULL;
	if(local_iden_table){
		tableToUse = local_iden_table;
	}else{
		printf("global\n");
		tableToUse = global_iden_table;
	}
	
	if (!hash_table_retrieve(tableToUse, name)){
		symbolTableIden * data = calloc(sizeof(*data), 1);
		symbolTableType * typeRef = hash_table_retrieve(global_type_table, type);
		data->name = name;
		data->type = typeRef;
		data->arraySize = arraySize > 0 ? arraySize : typeRef->array_size;
		if(arraySize > 0 && typeRef->array_size > 0){
			printf("Multi dim arrays not supported\n");
			exit(0);
		} 
		if(data->type){
			printf("HERE %s\n", name);
			hash_table_insert(tableToUse, name, data);
		}else{
			printf("The type %s does not exist\n", (char*)type);
			exit(0);
		}
	}else{
		printf("%s identifier already exists\n", (char*)name);
		exit(0);
	}

	return 0;
}

unsigned int hash (void *v)
{
	char *s0 = v;
	unsigned int h=0;
	char *s;
	for (s = s0; *s; s++) {
		h = h*65599 + *s;
	}
	
	return(h);
}


int key_compare(void *k1, void *k2) {
	//printf("in %s with %s and %s\n", __FUNCTION__, (char *) k1, (char *) k2);
	return strcmp(k1, k2);
}

void delete(void *v) {
	return;
}

Node *create_Node(enum NodeType t, void (*printNode)(struct Node *node, int parentId)) {
	Node *ret = malloc(sizeof(*ret));
	if (!ret) {
		perror("malloc");
		exit(1);
	}
	ret->nodeType = t;
	ret->printNode = printNode;
	return ret;
}

void printTree(Node *node, int parentId) {
	if (node) {
		node->printNode(node, parentId);
 	}
 	return;
 }

 void printGraphString(Node * root){
	fp = fopen("graph.txt", "w");
	fprintf(fp, "digraph G {\n");
	printTree(root, nodeId);
	fprintf(fp, "}\n");
	fflush(fp);
	fclose(fp);
}

void printNode(char *label, int myNodeId, int parentId) {
	fprintf(fp, "\t%d [label=\"%s\", shape=box];\n", myNodeId, label);

	if (parentId > 0) {
		fprintf(fp, "\t%d -> %d;\n", parentId, myNodeId);
	}
}

<% for (var key in nodeTypes) { %>
Node *create_<%- key %>(<%- nodeTypes[key].children.map(function(val){return "Node *"+val}).concat(nodeTypes[key].val.map(function(val){return val.type+" "+val.name})).join(", ") %>) {
	Node *ret = create_Node(<%- key+"_t" %>, &<%- key+"_p" %>);
	<%- nodeTypes[key].children.map(function(val){return "ret->children."+key+"."+val+" = "+val+";"}).concat(nodeTypes[key].val.map(function(val){ return "ret->children."+key+"."+val.name+"="+val.name+";"})).join("\n\t\t") %>
	return ret;
}
<% }; %>

<% for (var key in nodeTypes) { %>
void <%- key %>_p(Node * node, int parentId){
	nodeId++;
	int myNodeId = nodeId;
	int temp = 0;
	<%- nodeTypes[key].children.map(function(val){return "printTree(node->children."+key+"."+val+", myNodeId);"}).join("\n\t\t") %>
	<%- "printNode(\""+key+"\", myNodeId, parentId);" %>

	<%- nodeTypes[key].val.map(function(val){
		var cPrintSyn = "%s";
		if(val.type == "int"){
			cPrintSyn = "%d";
		}else if(val.type == "float"){
			cPrintSyn = "%f";
		}else if(val.type == "char"){
			cPrintSyn = "%c";
		}
		var top = "nodeId++;\n\ttemp = nodeId;\n\t"
		var a = 'fprintf(fp, "%d [label='+'\\"'+cPrintSyn+'\\"'+', shape=box];", temp, node->children.'+key+'.'+val.name+');\n\t'
		var b = 'fprintf(fp, "%d -> %d;", myNodeId, temp);'
		return top+a+b}) 
	%>	
};
<% }; %>

evaluatedNode * trav_node(Node * node){
	evaluatedNode * ret = calloc(sizeof(*ret), 1);
	if(node == NULL){
		return ret;
	}
	
	switch(node->nodeType){
		<% for (var key in nodeTypes) { %>
		case <%- nodeTypes[key].enumType %>:
			{
				//printf("%s\n", "<%- nodeTypes[key].enumType %>");

				<% if (key == nodeTypes.struct_def.name) {%>
					local_struct_iden_table = hash_table_create(128, delete, hash, key_compare);
				<% }; %>

				<% for (var child in nodeTypes[key].children) { var cEvNode = nodeTypes[key].children[child]+"_node" %>
					evaluatedNode * <%- cEvNode %> = trav_node(node->children.<%- nodeTypes[key].name %>.<%- nodeTypes[key].children[child] %>);
				<% }; %>

				<% if (key == nodeTypes.base_type_lit.name) {%>
					ret->strVal = node->children.base_type_lit.iden;
				<% } %>
				<% if (key == nodeTypes.type_iden.name) {%>
					cur_assign_var_decl_type = type_node->strVal;
					ret->strVal = type_node->strVal;
				<% } %>
				<% if (key == nodeTypes.identifier.name) {%>
					ret->strVal = node->children.identifier.val;
				<% } %>
				<% if (key == nodeTypes.var_name_iden.name) {%>
					ret->strVal = identifier_node->strVal;
					//if(array_decl_node){
					ret->intVal = array_decl_node->intVal;
					//}
				<% } %>
				<% if (key == nodeTypes.array_decl.name) {%>
					//printf("HERE %d\n", expr_node->intVal);
					ret->intVal = expr_node->intVal;
				<% } %>
				<% if (key == nodeTypes.type_decl.name) {%>
					insert_to_type_table(var_name_iden_node->strVal, var_name_iden_node->intVal, type_iden_node->strVal);
				<% } %>
				<% if (key == nodeTypes.expr.name) {%>
					printf("FUCK\n");
					if(node->children.expr.right_expr == NULL){
						ret->type = left_expr_node->type;
						ret->intVal = left_expr_node->intVal;
						ret->floatVal = left_expr_node->floatVal;
					}

					if (operator_node->strVal && ((strcmp(operator_node->strVal, "+") == 0) || (strcmp(operator_node->strVal, "-") == 0) || (strcmp(operator_node->strVal, "*") == 0) ||
						(strcmp(operator_node->strVal, "/") == 0))){

						printf("type %d == %d\n", left_expr_node->type, right_expr_node->type);
						if(left_expr_node->type == right_expr_node->type){
							ret->type = right_expr_node->type;
							if(ret->type == INTVAL || ret->type == CHARVAL){
								ret->intVal = left_expr_node->intVal + right_expr_node->intVal;
							}
							else if(ret->type == FLOATVAL){
								ret->floatVal = left_expr_node->floatVal + right_expr_node->floatVal;
							}
						}
						else {
							printf("Error incompatible types\n");
							exit(0);
						}
					}
				<% } %>
				<% if (key == nodeTypes.operator.name) {%>
					ret->strVal = node->children.operator.type;
				<% } %>
				<% if (key == nodeTypes.int_val.name) {%>
					ret->type = INTVAL;
					ret->intVal = node->children.int_val.val;
				<% } %>
				<% if (key == nodeTypes.float_val.name) {%>
					ret->type = FLOATVAL;
					ret->floatVal = node->children.float_val.val;
				<% } %>
				<% if (key == nodeTypes.char_val.name) {%>
					ret->type = CHARVAL;
					ret->intVal = node->children.char_val.val;
				<% } %>
				<% if (key == nodeTypes.struct_def.name) {%>
					printf("Structs not supported\n");
					exit(0);
				<% } %>
				<% if (key == nodeTypes.assign_var_list.name) {%>
					ret->intVal = assign_var_list_node->intVal + assign_var_decl_node->intVal;
				<% } %>
				<% if (key == nodeTypes.assign_var_decl.name) {%>
					symbolTableType* temp = hash_table_retrieve(global_type_table, type_iden_node->strVal);
					int size = temp->size;
					if (temp->array_size > 0){
						size *= temp->array_size;
					}
					//printf("SIZE IS %d\n", size);
					ret->intVal = size;
				<% } %>
				<% if (key == nodeTypes.assign_var_name_iden.name) {%>
					ret->strVal = var_name_iden_node->strVal;

					insert_symbol_table_iden_entry(var_name_iden_node->strVal, var_name_iden_node->intVal, cur_assign_var_decl_type);
					//TODO what do with var name iden array decl val
					//TODO what do with expr child
				<% } %>
				<% if (key == nodeTypes.var_name_iden.name) {%>
					ret->strVal = identifier_node->strVal;
					ret->intVal = array_decl_node->intVal;
				<% } %>
				<% if (key == nodeTypes.variable.name) {%>
					printf("CHECKING FOR VARIABLE: %s\n",  variable_node->strVal);
					symbolTableType *temp = hash_table_retrieve(global_type_table, variable_node->strVal);
					if (!temp){
						printf("Variable '%s' not declared\n", variable_node->strVal);
						exit(0);
					}
					if (strcmp(temp->baseType, "char") == 0){
						ret->type = CHARVAL;
					}
					else if (strcmp(temp->baseType, "int") == 0){
						ret->type = INTVAL;
					}
					else if (strcmp(temp->baseType, "float") == 0){
						ret->type = FLOATVAL;
					}
					ret->deferEval = 1; // Encountered a variable - cannot evaluate expression now
				<% } %>
				<% if (key == nodeTypes.non_rec_variable.name) {%>
					ret->strVal = iden_node->strVal;
					printf("CHECKING FOR VARIABLE: %s\n",  "FUCK YOU");
				<% } %>

				<% for (var child in nodeTypes[key].children) { var cEvNode = nodeTypes[key].children[child]+"_node" %>
					if(<%- cEvNode %>){
						//free(<%- cEvNode %>->strVal);
						free(<%- cEvNode %>);
					}
				<% }; %>
			}
			break;
		<% }; %>
		default:
			printf("BAD NOT TYPE????");
			break;
	}
	return ret;
}