//THIS FILE IS GENERATED IN proNode/nodes.jc
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "nodes.h"

extern int symbolTableOutput;

extern HashTable *global_type_table;
HashTable *local_struct_iden_table;
extern HashTable *global_iden_table;
extern HashTable *local_iden_table;
char * cur_assign_var_decl_type = NULL;
char * functionType = NULL;
int setFunctionType = 0;


void insert_to_type_table(char * newTypeName, int array_size, char * refTypeName){
	if(hash_table_retrieve(global_type_table, newTypeName)){
		printf("Duplicate types in type table cant insert %s (%s)\n", newTypeName, refTypeName);
		exit(0);
	}
	else{
		symbolTableType * typeRef = hash_table_retrieve(global_type_table, refTypeName);
		if(typeRef){
			symbolTableType * type = calloc(sizeof(*type), 1);
			type->name = newTypeName;
			type->size = typeRef->size;
			type->baseType = typeRef->baseType;
			type->refType = typeRef;
			if(typeRef->array_size > 0 && array_size > 0){
				printf("Error cannot make array of array in cflat\n");
				exit(0);
			}
			type->array_size = array_size;
			hash_table_insert(global_type_table, newTypeName, type);
		}
		else{
			printf("Type does not exist\n");
			exit(0);
		}
	}
}

void printSymbolTableType(symbolTableType * s){
	printf("----------------\nname: %s\nsize: %d\narray size: %d\nbase type:%s\n", s->name, s->size, s->array_size, s->baseType);
}

void printSymbolTableIden(symbolTableIden *s)
{
	printf("----------------\nname: %s\narray size: %d\ntype: %s\nis func: %d\n", s->name, s->arraySize, s->type->name, s->isFunc);
	if(s->isFunc){
		printf("params: ");
		functionArgs * itr = s->args;
		while(itr){
			printf("%s %s, ", itr->iden->type->name, itr->iden->name);
			itr = itr->next;
		}
		printf("\n");
	}
}

void printTypeTable(HashTable *h)
{
	symbolTableType *foo;
	foo = hash_table_retrieve_after(h, NULL);
	if (foo) {
		printSymbolTableType(foo);
	}
	while (foo) {
		foo = hash_table_retrieve_after(h, foo);
		if (foo) {
			printSymbolTableType(foo);
		}
	}
}

void printSymbolTable(HashTable *h)
{
	symbolTableIden *foo2 = hash_table_retrieve_after(h, NULL);
	if (foo2) {
		printf("New Iden Table\n");		
		printSymbolTableIden(foo2);
	}
	while (foo2) {
		foo2 = hash_table_retrieve_after(h, foo2);
		if (foo2) {
			printSymbolTableIden(foo2);
		}
	}
}


int nodeId = 0;
FILE* fp;
int structCounter = 0;

int insert_symbol_table_iden_entry(char * name, int arraySize, int isFunc, functionArgs * args, char * type){
	if(!isFunc && strcmp(type, "void") == 0){
		printf("Non function %s cannot have type void\n", name);
		exit(0);
	}
	HashTable * tableToUse = NULL;
	if(local_iden_table && !isFunc){
		tableToUse = local_iden_table;
	}
	else{
		//printf("global\n");
		tableToUse = global_iden_table;
	}
	
	if (!hash_table_retrieve(tableToUse, name)){
		symbolTableIden * data = calloc(sizeof(*data), 1);
		symbolTableType * typeRef = hash_table_retrieve(global_type_table, type);
		if(!typeRef){
			printf("Invalid type '%s' for identifier '%s'\n", type, name);
			exit(0);
		}
		data->name = name;
		data->type = typeRef;
		data->isFunc = isFunc;
		data->args = args;
		data->arraySize = arraySize > 0 ? arraySize : typeRef->array_size;
		if(arraySize > 0 && typeRef->array_size > 0){
			printf("Multi dimensional arrays not supported\n");
			exit(0);
		} 
		if(data->type){
			//printf("HERE %s\n", name);
			hash_table_insert(tableToUse, name, data);
		}
		else{
			printf("The type %s does not exist\n", (char*) type);
			exit(0);
		}
	}
	else{
		printf("%s identifier already exists\n", (char*) name);
		exit(0);
	}

	return 0;
}

symbolTableIden *retrieve_symbol_table_iden_entry(char *key){
	symbolTableIden * ret = NULL;
	if(local_iden_table){
		ret = hash_table_retrieve(local_iden_table, key);
	}

	if (!ret){
		ret = hash_table_retrieve(global_iden_table, key);
	}
	
	return ret;
}


int baseTypeToEnum(char * type){
	int ret = 0;
	
	if (strcmp(type, "char") == 0){
		return CHARVAL;
	}
	else if (strcmp(type, "int") == 0){
		return INTVAL;
	}
	else if (strcmp(type, "float") == 0){
		return FLOATVAL;
	}
	else if (strcmp(type, "void") == 0){
		return NONEVAL;
	}
	else{
		symbolTableType * typeRef = hash_table_retrieve(global_type_table, type);
		if (!typeRef){
			return -1;
		}
		return baseTypeToEnum(typeRef->baseType);
	}

	return ret;
}

unsigned int hash (void *v)
{
	char *s0 = v;
	unsigned int h=0;
	char *s;
	for (s = s0; *s; s++) {
		h = h*65599 + *s;
	}
	
	return(h);
}


int key_compare(void *k1, void *k2) {
	//printf("in %s with %s and %s\n", __FUNCTION__, (char *) k1, (char *) k2);
	return strcmp(k1, k2);
}

void delete(void *v) {
	return;
}

Node *create_Node(enum NodeType t, void (*printNode)(struct Node *node, int parentId)) {
	Node *ret = malloc(sizeof(*ret));
	if (!ret) {
		perror("malloc");
		exit(1);
	}
	ret->nodeType = t;
	ret->printNode = printNode;
	return ret;
}

void printTree(Node *node, int parentId) {
	if (node) {
		node->printNode(node, parentId);
 	}
 	return;
 }

 void printGraphString(Node * root){
	fp = fopen("graph.txt", "w");
	fprintf(fp, "digraph G {\n");
	printTree(root, nodeId);
	fprintf(fp, "}\n");
	fflush(fp);
	fclose(fp);
}

void printNode(char *label, int myNodeId, int parentId) {
	fprintf(fp, "\t%d [label=\"%s\", shape=box];\n", myNodeId, label);

	if (parentId > 0) {
		fprintf(fp, "\t%d -> %d;\n", parentId, myNodeId);
	}
}

<% for (var key in nodeTypes) { %>
Node *create_<%- key %>(<%- nodeTypes[key].children.map(function(val){return "Node *"+val}).concat(nodeTypes[key].val.map(function(val){return val.type+" "+val.name})).join(", ") %>) {
	Node *ret = create_Node(<%- key+"_t" %>, &<%- key+"_p" %>);
	<%- nodeTypes[key].children.map(function(val){return "ret->children."+key+"."+val+" = "+val+";"}).concat(nodeTypes[key].val.map(function(val){ return "ret->children."+key+"."+val.name+"="+val.name+";"})).join("\n\t\t") %>
	return ret;
}
<% }; %>

<% for (var key in nodeTypes) { %>
void <%- key %>_p(Node * node, int parentId){
	nodeId++;
	int myNodeId = nodeId;
	int temp = 0;
	<%- nodeTypes[key].children.map(function(val){return "printTree(node->children."+key+"."+val+", myNodeId);"}).join("\n\t\t") %>
	<%- "printNode(\""+key+"\", myNodeId, parentId);" %>

	<%- nodeTypes[key].val.map(function(val){
		var cPrintSyn = "%s";
		if(val.type == "int"){
			cPrintSyn = "%d";
		}
		else if(val.type == "float"){
			cPrintSyn = "%f";
		}
		else if(val.type == "char"){
			cPrintSyn = "%c";
		}
		var top = "nodeId++;\n\ttemp = nodeId;\n\t"
		var a = 'fprintf(fp, "%d [label='+'\\"'+cPrintSyn+'\\"'+', shape=box];", temp, node->children.'+key+'.'+val.name+');\n\t'
		var b = 'fprintf(fp, "%d -> %d;", myNodeId, temp);'
		return top+a+b}) 
	%>	
};
<% }; %>

evaluatedNode * trav_node(Node * node){
	evaluatedNode * ret = calloc(sizeof(*ret), 1);
	if(node == NULL){
		return ret;
	}
	
	switch(node->nodeType){
		<% for (var key in nodeTypes) { %>
		case <%- nodeTypes[key].enumType %>:
			{
				//printf("%s\n", "<%- nodeTypes[key].enumType %>");

				<% if (key == nodeTypes.struct_def.name) {%>
					local_struct_iden_table = hash_table_create(128, delete, hash, key_compare);
				<% }; %>

				<% if (key == nodeTypes.function_def.name) {%>

					local_iden_table = hash_table_create(128, delete, hash, key_compare);
					
					evaluatedNode * iden_node = trav_node(node->children.function_def.iden);
					evaluatedNode * param_list_node = trav_node(node->children.function_def.param_list);
					insert_symbol_table_iden_entry(iden_node->strVal, 0, 1, param_list_node->params, functionType);
					evaluatedNode * function_body_node = trav_node(node->children.function_def.function_body);
				<% }; %>
				<% if (key == nodeTypes.assign_var_decl.name) {%>
					if(node->children.assign_var_decl.comma_iden_assign_list->nodeType == function_def_t){
						setFunctionType = 1;
					}
				<% }; %>
				
				<% for (var child in nodeTypes[key].children) { var cEvNode = nodeTypes[key].children[child]+"_node" %>
					<% if(key != nodeTypes.function_def.name){ %>
						evaluatedNode * <%- cEvNode %> = trav_node(node->children.<%- nodeTypes[key].name %>.<%- nodeTypes[key].children[child] %>);
					<% } %>
				<% }; %>

				<% if (key == nodeTypes.base_type_lit.name) {%>
					ret->strVal = node->children.base_type_lit.iden;
				<% } %>
				<% if (key == nodeTypes.type_iden.name) {%>
					if(setFunctionType){
						functionType = type_node->strVal;
						setFunctionType = 0;
					}else{
						cur_assign_var_decl_type = type_node->strVal;
					}
					
					ret->strVal = type_node->strVal;
				<% } %>
				<% if (key == nodeTypes.identifier.name) {%>
					ret->strVal = node->children.identifier.val;
				<% } %>
				<% if (key == nodeTypes.var_name_iden.name) {%>
					ret->strVal = identifier_node->strVal;
					if (array_decl_node->deferEval){
						printf("Cannot define variable length array for '%s'\n", identifier_node->strVal);
						exit(0);
					}
					ret->intVal = array_decl_node->intVal;

				<% } %>
				<% if (key == nodeTypes.array_decl.name) {%>
					if (expr_node->type != INTVAL){
						printf("Array size must be integer value\n");
						exit(0);
					}
					ret->intVal = expr_node->intVal;
					ret->deferEval = expr_node->deferEval;
				<% } %>
				<% if (key == nodeTypes.type_decl.name) {%>
					insert_to_type_table(var_name_iden_node->strVal, var_name_iden_node->intVal, type_iden_node->strVal);
				<% } %>
				<% if (key == nodeTypes.expr.name) {%>
					if(node->children.expr.right_expr == NULL && node->children.expr.operator == NULL){
						//SINGLE VAR/NUMBER/CHAR
						ret->type = left_expr_node->type;
						ret->intVal = left_expr_node->intVal;
						ret->floatVal = left_expr_node->floatVal;
						if(node->children.expr.left_expr->nodeType == variable_t){
							//symbolTableIden * iden = retr
							ret->isArray = left_expr_node->isArray;
						}
					}else{
						if(left_expr_node->isArray || right_expr_node->isArray){
							printf("Cannot use operator on array\n");
							exit(0);
						}
						if(node->children.expr.operator &&  node->children.expr.right_expr && node->children.expr.left_expr == NULL){
							//UNARY + - -- ++ on left side
							ret->type = right_expr_node->type;
							ret->intVal = right_expr_node->intVal;
							ret->floatVal = right_expr_node->floatVal;
							ret->type = right_expr_node->type;
							if(operator_node->strVal){
								if(strcmp(operator_node->strVal, "+") == 0){

								}else if(strcmp(operator_node->strVal, "-") == 0){
									ret->floatVal = -ret->floatVal;
									ret->intVal = -ret->intVal;
								}else if(strcmp(operator_node->strVal, "++") == 0){
									if(!right_expr_node->isVar){
										printf("Cannot use ++/-- on non var\n");
										exit(0);
									}
									ret->floatVal = ret->floatVal+1;
									ret->intVal = ret->intVal+1;
								}else if(strcmp(operator_node->strVal, "--") == 0){
									if(!right_expr_node->isVar){
										printf("Cannot use ++/-- on non var\n");
										exit(0);
									}
									ret->floatVal = ret->floatVal-1;
									ret->intVal = ret->intVal-1;
								}
							}
						}else if(node->children.expr.operator &&  node->children.expr.right_expr == NULL && node->children.expr.left_expr){
							ret->type = left_expr_node->type;
							ret->intVal = left_expr_node->intVal;
							ret->floatVal = left_expr_node->floatVal;
							ret->type = left_expr_node->type;
							if(operator_node->strVal){
								if(strcmp(operator_node->strVal, "+") == 0){

								}else if(strcmp(operator_node->strVal, "-") == 0){

								}else if(strcmp(operator_node->strVal, "++") == 0){
									if(!left_expr_node->isVar){
										printf("Cannot use ++/-- on non var\n");
										exit(0);
									}
								}else if(strcmp(operator_node->strVal, "--") == 0){
									if(!left_expr_node->isVar){
										printf("Cannot use ++/-- on non var\n");
										exit(0);
									}
								}
							}
						}else{
							ret->type = left_expr_node->type;
							ret->intVal = left_expr_node->intVal;
							ret->floatVal = left_expr_node->floatVal;
							ret->type = left_expr_node->type;
							if (node->children.expr.right_expr){
								ret->deferEval = (ret->deferEval || right_expr_node->deferEval);
							}

							if (node->children.expr.left_expr){
								ret->deferEval = (ret->deferEval || left_expr_node->deferEval);
							}

							if (operator_node->strVal && ((strcmp(operator_node->strVal, "+") == 0) || (strcmp(operator_node->strVal, "-") == 0) || (strcmp(operator_node->strVal, "*") == 0) ||
								(strcmp(operator_node->strVal, "/") == 0))){

								if(left_expr_node->type != right_expr_node->type){
									printf("Expression contains incompatible types\n");
									exit(0);
								}
								ret->type = right_expr_node->type;
								if (strcmp(operator_node->strVal, "+") == 0){
									if(ret->type == INTVAL || ret->type == CHARVAL){
										ret->intVal = left_expr_node->intVal + right_expr_node->intVal;
									}
									else if(ret->type == FLOATVAL){
										ret->floatVal = left_expr_node->floatVal + right_expr_node->floatVal;
									}
								}
								else if (strcmp(operator_node->strVal, "-") == 0){
									if(ret->type == INTVAL || ret->type == CHARVAL){
										ret->intVal = left_expr_node->intVal - right_expr_node->intVal;
									}
									else if(ret->type == FLOATVAL){
										ret->floatVal = left_expr_node->floatVal - right_expr_node->floatVal;
									}
								}
								else if (strcmp(operator_node->strVal, "*") == 0){
									if(ret->type == INTVAL || ret->type == CHARVAL){
										ret->intVal = left_expr_node->intVal * right_expr_node->intVal;
									}
									else if(ret->type == FLOATVAL){
										ret->floatVal = left_expr_node->floatVal * right_expr_node->floatVal;
									}
								}
								else if (strcmp(operator_node->strVal, "/") == 0){
									if(ret->type == INTVAL || ret->type == CHARVAL){
										ret->intVal = left_expr_node->intVal / right_expr_node->intVal;
									}
									else if(ret->type == FLOATVAL){
										ret->floatVal = left_expr_node->floatVal / right_expr_node->floatVal;
									}
								}
							}
							else if(!operator_node->strVal){
								//expr only evaluates to array if there is no operator on an array
								ret->isArray = left_expr_node->isArray;
								//TODO cause error when operator is performed on array
							}
						}
					}
					
				<% } %>
				<% if (key == nodeTypes.operator.name) {%>
					ret->strVal = node->children.operator.type;
				<% } %>
				<% if (key == nodeTypes.int_val.name) {%>
					ret->type = INTVAL;
					ret->intVal = node->children.int_val.val;
				<% } %>
				<% if (key == nodeTypes.float_val.name) {%>
					ret->type = FLOATVAL;
					ret->floatVal = node->children.float_val.val;
				<% } %>
				<% if (key == nodeTypes.char_val.name) {%>
					ret->type = CHARVAL;
					ret->intVal = node->children.char_val.val;
				<% } %>
				<% if (key == nodeTypes.struct_def.name) {%>
					printf("Structs not supported\n");
					exit(0);
				<% } %>
				<% if (key == nodeTypes.assign_var_list.name) {%>
					ret->intVal = assign_var_list_node->intVal + assign_var_decl_node->intVal;
				<% } %>
				<% if (key == nodeTypes.assign_var_decl.name) {%>
					symbolTableType* temp = hash_table_retrieve(global_type_table, type_iden_node->strVal);
					int size = temp->size;
					if (temp->array_size > 0){
						size *= temp->array_size;
					}
					//printf("SIZE IS %d\n", size);
					ret->intVal = size;
				<% } %>
				<% if (key == nodeTypes.assign_var_name_iden.name) {%>
					ret->strVal = var_name_iden_node->strVal;

					insert_symbol_table_iden_entry(var_name_iden_node->strVal, var_name_iden_node->intVal, 0, NULL,cur_assign_var_decl_type);
					if(node->children.assign_var_name_iden.expr && expr_node->type != baseTypeToEnum(cur_assign_var_decl_type)){
						printf("Type mismatch in variable decleration assignment\n");
						exit(0);
					}
					//TODO what do with var name iden array decl val
					//TODO what do with expr child
				<% } %>
				<% if (key == nodeTypes.variable.name) {%>
					symbolTableIden *tableIden = retrieve_symbol_table_iden_entry(variable_node->strVal);
					if (!tableIden){
						printf("Variable '%s' not declared\n", variable_node->strVal);
						exit(0);
					}
					symbolTableType * typeRef = tableIden->type;
					ret->isArray = tableIden->arraySize;
					if (strcmp( typeRef->baseType, "char") == 0){
						ret->type = CHARVAL;
					}
					else if (strcmp( typeRef->baseType, "int") == 0){
						ret->type = INTVAL;
					}
					else if (strcmp( typeRef->baseType, "float") == 0){
						ret->type = FLOATVAL;
					}
					ret->isVar = 1;
					ret->deferEval = 1; // Encountered a variable - cannot evaluate expression now
				<% } %>
				<% if (key == nodeTypes.non_rec_variable.name) {%>
					symbolTableIden *tableIden = retrieve_symbol_table_iden_entry(iden_node->strVal);
					// if (!node->children.non_rec_variable.array_decl && tableIden && tableIden->arraySize){
					// 	printf("Missing array index for variable '%s'\n", iden_node->strVal);
					// 	exit(0);
					// }
					ret->intVal = array_decl_node->intVal;
					ret->strVal = iden_node->strVal;
				<% } %>
				<% if (key == nodeTypes.function_def.name) {%>
					printf("Function %s\n\n", iden_node->strVal);
					printSymbolTable(local_iden_table);
					hash_table_destroy(local_iden_table);
					local_iden_table = NULL;
				<% } %>

				<% if (key == nodeTypes.assignment.name) {%>
					if (variable_node->type != expr_node->type){
						printf("Cannot assign incompatible types\n");
						exit(0);
					}

					switch (expr_node->type){
						case CHARVAL:
						case INTVAL:
							ret->intVal = expr_node->intVal;
							break;
						case FLOATVAL:
							ret->floatVal = expr_node->floatVal;
					}
					ret->type = variable_node->type;
				<% } %>


				<% if (key == nodeTypes.function_call.name) {%>

					if (strcmp(iden_node->strVal, "sizeof") == 0 || strcmp(iden_node->strVal, "putc") == 0 || strcmp(iden_node->strVal, "puti") == 0 || strcmp(iden_node->strVal, "putf") == 0){
						functionArgs * givenParamIter = expr_list_node->params;
						if ((!givenParamIter) || givenParamIter->next){
							printf("Invalid use of %s() operator\n", iden_node->strVal);
							exit(0);
						}

						if(strcmp(iden_node->strVal, "putc") == 0){
							if(givenParamIter->type != CHARVAL){
								printf("Invalid use of %s() operator\n", iden_node->strVal);
								exit(0);
							}
						}else if(strcmp(iden_node->strVal, "puti") == 0){
							if(givenParamIter->type != INTVAL){
								printf("Invalid use of %s() operator\n", iden_node->strVal);
								exit(0);
							}
						}else if(strcmp(iden_node->strVal, "putf") == 0){
							if(givenParamIter->type != FLOATVAL){
								printf("Invalid use of %s() operator\n", iden_node->strVal);
								exit(0);
							}
						}else if(strcmp(iden_node->strVal, "sizeof") == 0){
							ret->type = INTVAL;
						}
					}else{
						symbolTableIden *funcIden;funcIden = retrieve_symbol_table_iden_entry(iden_node->strVal);

						if(!funcIden){
							printf("Function '%s' does not exitst\n", iden_node->strVal);
							exit(0);
						}
						functionArgs * givenParamIter = expr_list_node->params;
						functionArgs * paramIter = funcIden->args;
						while(givenParamIter || paramIter){
							if(paramIter && !givenParamIter){
								printf("Less parameters given than expected for function '%s' call\n", iden_node->strVal);
								exit(0);
							}
							else if(givenParamIter && !paramIter){
								printf("More parameters given than expected for function '%s' call\n", iden_node->strVal);
								exit(0);
							}
							if(((givenParamIter->isArray > 0) != (paramIter->iden->arraySize > 0))|| givenParamIter->type != baseTypeToEnum(paramIter->iden->type->baseType)){
								printf("Given parameter type does not match expected type for function '%s' call\n", iden_node->strVal);
								exit(0);
							}
							givenParamIter = givenParamIter->next;
							paramIter = paramIter->next;
						}

						if (!funcIden){
							printf("Function '%s' not defined\n", iden_node->strVal);
							exit(0);
						}

						symbolTableType *funcType = funcIden->type;
						ret->type = baseTypeToEnum(funcType->baseType);
						ret->deferEval = 1; // Encountered a variable - cannot evaluate expression now
					}					

				<% } %>

				<% if (key == nodeTypes.param_list.name) {%>
					ret->params = calloc(sizeof(*(ret->params)), 1);
					if(param_list_node->params){
						ret->params->next = param_list_node->params;
					}
					ret->params->iden = retrieve_symbol_table_iden_entry(param_node->strVal);
					// if(ret->params->iden){
					// 	ret->params->isArray = ret->params->iden->arraySize > 0;
					// }
				<% }; %>
				<% if (key == nodeTypes.param.name) {%>
					ret->strVal = iden_node->strVal;
					insert_symbol_table_iden_entry(iden_node->strVal, iden_node->intVal, 0, NULL,type_iden_node->strVal);
				<% }; %>
				<% if (key == nodeTypes.comma_expr_list.name) {%>
					ret->params = calloc(sizeof(*(ret->params)), 1);
					if(comma_expr_list_node->params){
						ret->params->next = comma_expr_list_node->params;
					}
					ret->params->type = expr_node->type;
					ret->params->isArray = expr_node->isArray;
				<% }; %>
				<% if (key == nodeTypes.return_stmt.name) {%>
					if (expr_node->type != baseTypeToEnum(functionType)){
						printf("Return type '%d' does not match expected return type '%s'\n", expr_node->type, functionType);
						exit(0);
					}
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>

				<% for (var child in nodeTypes[key].children) { var cEvNode = nodeTypes[key].children[child]+"_node" %>
					if(<%- cEvNode %>){
						//free(<%- cEvNode %>->strVal);
						free(<%- cEvNode %>);
					}
				<% }; %>
			}
			break;
		<% }; %>
		default:
			printf("SHOULDN'T BE HERE\n");
			break;
	}
	return ret;
}