//THIS FILE IS GENERATED IN proNode/nodes.jc
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "nodes.h"

extern int symbolTableOutput;

extern HashTable *global_type_table;
HashTable *local_struct_iden_table;
extern HashTable *global_iden_table;
extern HashTable *local_iden_table;
char * cur_assign_var_decl_type = NULL;

void insert_to_type_table(char * newTypeName, int array_size, char * refTypeName){
	if(hash_table_retrieve(global_type_table, newTypeName)){
		printf("Duplicate types in type table cant insert %s (%s)\n", newTypeName, refTypeName);
		exit(0);
	}
	else{
		symbolTableType * typeRef = hash_table_retrieve(global_type_table, refTypeName);
		if(typeRef){
			symbolTableType * type = calloc(sizeof(*type), 1);
			type->name = newTypeName;
			type->size = typeRef->size;
			type->baseType = typeRef->baseType;
			type->refType = typeRef;
			if(typeRef->array_size > 0 && array_size > 0){
				printf("Error cannot make array of array in cflat\n");
				exit(0);
			}
			type->array_size = array_size;
			hash_table_insert(global_type_table, newTypeName, type);
		}
		else{
			printf("Type does not exist\n");
			exit(0);
		}
	}
}

void printSymbolTableType(symbolTableType * s){
	printf("----------------\nname: %s\nsize: %d\narray size: %d\nbase type:%s\n", s->name, s->size, s->array_size, s->baseType);
}

void printSymbolTableIden(symbolTableIden *s)
{
	printf("----------------\nname: %s\narray size: %d\ntype: %s\nis func: %d\n", s->name, s->arraySize, s->type->name, s->isFunc);
}

void printTypeTable(HashTable *h)
{
	symbolTableType *foo;
	foo = hash_table_retrieve_after(h, NULL);
	if (foo) {
		printSymbolTableType(foo);
	}
	while (foo) {
		foo = hash_table_retrieve_after(h, foo);
		if (foo) {
			printSymbolTableType(foo);
		}
	}
}

void printSymbolTable(HashTable *h)
{
	symbolTableIden *foo2 = hash_table_retrieve_after(h, NULL);
	if (foo2) {
		printf("New Iden Table\n");		
		printSymbolTableIden(foo2);
	}
	while (foo2) {
		foo2 = hash_table_retrieve_after(h, foo2);
		if (foo2) {
			printSymbolTableIden(foo2);
		}
	}
}


int nodeId = 0;
FILE* fp;
int structCounter = 0;

int insert_symbol_table_iden_entry(char * name, int arraySize, int isFunc, char * type){
	if(!isFunc && strcmp(type, "void") == 0){
		printf("Non function %s cannot have type void\n", name);
		exit(0);
	}
	HashTable * tableToUse = NULL;
	if(local_iden_table){
		tableToUse = local_iden_table;
	}
	else{
		//printf("global\n");
		tableToUse = global_iden_table;
	}
	
	if (!hash_table_retrieve(tableToUse, name)){
		symbolTableIden * data = calloc(sizeof(*data), 1);
		symbolTableType * typeRef = hash_table_retrieve(global_type_table, type);
		if(!typeRef){
			printf("Invalid type '%s' for identifier '%s'\n", type, name);
			exit(0);
		}
		data->name = name;
		data->type = typeRef;
		data->isFunc = isFunc;
		data->arraySize = arraySize > 0 ? arraySize : typeRef->array_size;
		if(arraySize > 0 && typeRef->array_size > 0){
			printf("Multi dimensional arrays not supported\n");
			exit(0);
		} 
		if(data->type){
			//printf("HERE %s\n", name);
			hash_table_insert(tableToUse, name, data);
		}
		else{
			printf("The type %s does not exist\n", (char*) type);
			exit(0);
		}
	}
	else{
		printf("%s identifier already exists\n", (char*) name);
		exit(0);
	}

	return 0;
}

symbolTableIden *retrieve_symbol_table_iden_entry(char *key){
	symbolTableIden * ret = NULL;
	if(local_iden_table){
		ret = hash_table_retrieve(local_iden_table, key);
	}

	if (!ret){
		ret = hash_table_retrieve(global_iden_table, key);
	}
	
	return ret;
}

unsigned int hash (void *v)
{
	char *s0 = v;
	unsigned int h=0;
	char *s;
	for (s = s0; *s; s++) {
		h = h*65599 + *s;
	}
	
	return(h);
}


int key_compare(void *k1, void *k2) {
	//printf("in %s with %s and %s\n", __FUNCTION__, (char *) k1, (char *) k2);
	return strcmp(k1, k2);
}

void delete(void *v) {
	return;
}

Node *create_Node(enum NodeType t, void (*printNode)(struct Node *node, int parentId)) {
	Node *ret = malloc(sizeof(*ret));
	if (!ret) {
		perror("malloc");
		exit(1);
	}
	ret->nodeType = t;
	ret->printNode = printNode;
	return ret;
}

void printTree(Node *node, int parentId) {
	if (node) {
		node->printNode(node, parentId);
 	}
 	return;
 }

 void printGraphString(Node * root){
	fp = fopen("graph.txt", "w");
	fprintf(fp, "digraph G {\n");
	printTree(root, nodeId);
	fprintf(fp, "}\n");
	fflush(fp);
	fclose(fp);
}

void printNode(char *label, int myNodeId, int parentId) {
	fprintf(fp, "\t%d [label=\"%s\", shape=box];\n", myNodeId, label);

	if (parentId > 0) {
		fprintf(fp, "\t%d -> %d;\n", parentId, myNodeId);
	}
}

<% for (var key in nodeTypes) { %>
Node *create_<%- key %>(<%- nodeTypes[key].children.map(function(val){return "Node *"+val}).concat(nodeTypes[key].val.map(function(val){return val.type+" "+val.name})).join(", ") %>) {
	Node *ret = create_Node(<%- key+"_t" %>, &<%- key+"_p" %>);
	<%- nodeTypes[key].children.map(function(val){return "ret->children."+key+"."+val+" = "+val+";"}).concat(nodeTypes[key].val.map(function(val){ return "ret->children."+key+"."+val.name+"="+val.name+";"})).join("\n\t\t") %>
	return ret;
}
<% }; %>

<% for (var key in nodeTypes) { %>
void <%- key %>_p(Node * node, int parentId){
	nodeId++;
	int myNodeId = nodeId;
	int temp = 0;
	<%- nodeTypes[key].children.map(function(val){return "printTree(node->children."+key+"."+val+", myNodeId);"}).join("\n\t\t") %>
	<%- "printNode(\""+key+"\", myNodeId, parentId);" %>

	<%- nodeTypes[key].val.map(function(val){
		var cPrintSyn = "%s";
		if(val.type == "int"){
			cPrintSyn = "%d";
		}
		else if(val.type == "float"){
			cPrintSyn = "%f";
		}
		else if(val.type == "char"){
			cPrintSyn = "%c";
		}
		var top = "nodeId++;\n\ttemp = nodeId;\n\t"
		var a = 'fprintf(fp, "%d [label='+'\\"'+cPrintSyn+'\\"'+', shape=box];", temp, node->children.'+key+'.'+val.name+');\n\t'
		var b = 'fprintf(fp, "%d -> %d;", myNodeId, temp);'
		return top+a+b}) 
	%>	
};
<% }; %>

evaluatedNode * trav_node(Node * node){
	evaluatedNode * ret = calloc(sizeof(*ret), 1);
	if(node == NULL){
		return ret;
	}
	
	switch(node->nodeType){
		<% for (var key in nodeTypes) { %>
		case <%- nodeTypes[key].enumType %>:
			{
				//printf("%s\n", "<%- nodeTypes[key].enumType %>");

				<% if (key == nodeTypes.struct_def.name) {%>
					local_struct_iden_table = hash_table_create(128, delete, hash, key_compare);
				<% }; %>

				<% if (key == nodeTypes.function_body.name) {%>
					local_iden_table = hash_table_create(128, delete, hash, key_compare);
				<% }; %>

				<% for (var child in nodeTypes[key].children) { var cEvNode = nodeTypes[key].children[child]+"_node" %>
					evaluatedNode * <%- cEvNode %> = trav_node(node->children.<%- nodeTypes[key].name %>.<%- nodeTypes[key].children[child] %>);
				<% }; %>

				<% if (key == nodeTypes.base_type_lit.name) {%>
					ret->strVal = node->children.base_type_lit.iden;
				<% } %>
				<% if (key == nodeTypes.type_iden.name) {%>
					cur_assign_var_decl_type = type_node->strVal;
					ret->strVal = type_node->strVal;
				<% } %>
				<% if (key == nodeTypes.identifier.name) {%>
					ret->strVal = node->children.identifier.val;
				<% } %>
				<% if (key == nodeTypes.var_name_iden.name) {%>
					ret->strVal = identifier_node->strVal;
					//if(array_decl_node){
					ret->intVal = array_decl_node->intVal;
					//}
				<% } %>
				<% if (key == nodeTypes.array_decl.name) {%>
					//printf("HERE %d\n", expr_node->intVal);
					ret->intVal = expr_node->intVal;
				<% } %>
				<% if (key == nodeTypes.type_decl.name) {%>
					insert_to_type_table(var_name_iden_node->strVal, var_name_iden_node->intVal, type_iden_node->strVal);
				<% } %>
				<% if (key == nodeTypes.expr.name) {%>
					if(node->children.expr.right_expr == NULL){
						ret->type = left_expr_node->type;
						ret->intVal = left_expr_node->intVal;
						ret->floatVal = left_expr_node->floatVal;
					}

					if (operator_node->strVal && ((strcmp(operator_node->strVal, "+") == 0) || (strcmp(operator_node->strVal, "-") == 0) || (strcmp(operator_node->strVal, "*") == 0) ||
						(strcmp(operator_node->strVal, "/") == 0))){
						if(left_expr_node->isArray || right_expr_node->isArray){
							printf("Cannot perform %s on array\n", operator_node->strVal);
							exit(0);
						}
						if(left_expr_node->type == right_expr_node->type){
							ret->type = right_expr_node->type;
							if(ret->type == INTVAL || ret->type == CHARVAL){
								ret->intVal = left_expr_node->intVal + right_expr_node->intVal;
							}
							else if(ret->type == FLOATVAL){
								ret->floatVal = left_expr_node->floatVal + right_expr_node->floatVal;
							}
						}
						else {
							printf("Error incompatible types\n");
							exit(0);
						}
					}
					else if(!operator_node->strVal){
						//expr only evaluates to array if there is no operator on an array
						ret->isArray = left_expr_node->isArray;
						//TODO cause error when operator is performed on array
					}
				<% } %>
				<% if (key == nodeTypes.operator.name) {%>
					ret->strVal = node->children.operator.type;
				<% } %>
				<% if (key == nodeTypes.int_val.name) {%>
					ret->type = INTVAL;
					ret->intVal = node->children.int_val.val;
				<% } %>
				<% if (key == nodeTypes.float_val.name) {%>
					ret->type = FLOATVAL;
					ret->floatVal = node->children.float_val.val;
				<% } %>
				<% if (key == nodeTypes.char_val.name) {%>
					ret->type = CHARVAL;
					ret->intVal = node->children.char_val.val;
				<% } %>
				<% if (key == nodeTypes.struct_def.name) {%>
					printf("Structs not supported\n");
					exit(0);
				<% } %>
				<% if (key == nodeTypes.assign_var_list.name) {%>
					ret->intVal = assign_var_list_node->intVal + assign_var_decl_node->intVal;
				<% } %>
				<% if (key == nodeTypes.assign_var_decl.name) {%>
					symbolTableType* temp = hash_table_retrieve(global_type_table, type_iden_node->strVal);
					int size = temp->size;
					if (temp->array_size > 0){
						size *= temp->array_size;
					}
					//printf("SIZE IS %d\n", size);
					ret->intVal = size;
				<% } %>
				<% if (key == nodeTypes.assign_var_name_iden.name) {%>
					ret->strVal = var_name_iden_node->strVal;

					insert_symbol_table_iden_entry(var_name_iden_node->strVal, var_name_iden_node->intVal, 0, cur_assign_var_decl_type);
					//TODO what do with var name iden array decl val
					//TODO what do with expr child
				<% } %>
				<% if (key == nodeTypes.variable.name) {%>
					symbolTableIden *tableIden = retrieve_symbol_table_iden_entry(variable_node->strVal);
					if (!tableIden){
						printf("Variable '%s' not declared\n", variable_node->strVal);
						exit(0);
					}
					symbolTableType * typeRef = tableIden->type;
					ret->isArray = tableIden->arraySize;
					if (strcmp( typeRef->baseType, "char") == 0){
						ret->type = CHARVAL;
					}
					else if (strcmp( typeRef->baseType, "int") == 0){
						ret->type = INTVAL;
					}
					else if (strcmp( typeRef->baseType, "float") == 0){
						ret->type = FLOATVAL;
					}
					ret->deferEval = 1; // Encountered a variable - cannot evaluate expression now
				<% } %>
				<% if (key == nodeTypes.non_rec_variable.name) {%>
					ret->strVal = iden_node->strVal;
				<% } %>
				<% if (key == nodeTypes.function_def.name) {%>
					printf("Function %s ended\n\n", iden_node->strVal);
					insert_symbol_table_iden_entry(iden_node->strVal, 0, 1, cur_assign_var_decl_type);
				<% } %>

				<% if (key == nodeTypes.assignment.name) {%>
					if (variable_node->type != expr_node->type){
						printf("Cannot assign incompatible types\n");
						exit(0);
					}
					if(expr_node->isArray){
						printf("Expr of assignment cannot be array\n");
						exit(0);
					}
					switch (expr_node->type){
						case CHARVAL:
						case INTVAL:
							ret->intVal = expr_node->intVal;
							break;
						case FLOATVAL:
							ret->floatVal = expr_node->floatVal;
					}
					ret->type = variable_node->type;
				<% } %>

				<% if (key == nodeTypes.function_body.name) {%>
					printSymbolTable(local_iden_table);
					hash_table_destroy(local_iden_table);
					local_iden_table = NULL;
				<% }; %>


				<% if (key == nodeTypes.function_call.name) {%>
					symbolTableIden *temp2 = retrieve_symbol_table_iden_entry(iden_node->strVal);
					if (!temp2){
						printf("Function '%s' not defined\n", iden_node->strVal);
						exit(0);
					}
					symbolTableType *temp = temp2->type;

					if (strcmp(temp->baseType, "char") == 0){
						ret->type = CHARVAL;
					}
					else if (strcmp(temp->baseType, "int") == 0){
						ret->type = INTVAL;
					}
					else if (strcmp(temp->baseType, "float") == 0){
						ret->type = FLOATVAL;
					}
					ret->deferEval = 1; // Encountered a variable - cannot evaluate expression now
				<% } %>

				<% if (key == nodeTypes.param_list.name) {%>
					ret->params = calloc(sizeof(*(ret->params)), 1);
					if(param_list_node->params){
						ret->params->next = param_list_node->params;
					}
					ret->params->iden = retrieve_symbol_table_iden_entry(param_node->strVal);
				<% }; %>
				<% if (key == nodeTypes.param.name) {%>
					ret->strVal = iden_node->strVal;
					insert_symbol_table_iden_entry(iden_node->strVal, 0, 0, type_iden_node->strVal);
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>
				<% if (key == nodeTypes.function_body.name) {%>
				<% }; %>

				<% for (var child in nodeTypes[key].children) { var cEvNode = nodeTypes[key].children[child]+"_node" %>
					if(<%- cEvNode %>){
						//free(<%- cEvNode %>->strVal);
						free(<%- cEvNode %>);
					}
				<% }; %>
			}
			break;
		<% }; %>
		default:
			printf("SHOULDN'T BE HERE\n");
			break;
	}
	return ret;
}